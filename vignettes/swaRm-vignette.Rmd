---
title: "`swaRm` - a package for processing collective movement data"
author: "Simon Garnier - <a href='https://twitter.com/sjmgarnier'>@sjmgarnier</a>"
date: "`r Sys.Date()`"
output:
  html_document:
    css: custom.css
    fig_caption: true
    fig_height: 6
    fig_width: 8
    number_sections: true
    theme: cosmo
    highlight: pygments
    toc: true
    code_folding: show
  pdf_document:
    toc: true
vignette: |
  %\VignetteIndexEntry{Vignette Title} 
  %\VignetteEngine{knitr::rmarkdown} 
  %\VignetteEncoding{UTF-8}
---

---

# Introduction

The goal of this vignette is to demonstrate the functionalities of the `swaRm` 
package for processing collective movement data. 

[Back to top]("#")

---

# Installation

`swaRm` can be installed from the [SwarmLab](http://www.theswarmlab.com)'s 
[`drat` repository](https://github.com/swarm-lab/drat) by running the following
lines in your R terminal: 

```{r, eval=FALSE, message=FALSE, warning=FALSE}
install.packages("drat")  # This line is required if drat is not present 
                          # in your R installation.

drat::addRepo("swarm-lab")
install.packages("swaRm")
```

If you want to receive package updates automatically, you can add the `drat` 
repository to your R installation permanently by adding the line 
`drat::addRepo("swarm-lab")` to your `.Rprofile` file.

[Back to top]("#")

---

# Preparing a trajectory data table

The `swaRm` package ships with a number of example data files that we will use 
for demonstrating its functioning. 

First, we will load in memory the first of these example data files. 

```{r, message=FALSE, warning=FALSE}
filePath <- system.file("extdata/01.csv", package = "swaRm")
dat <- read.csv(filePath)
head(dat)
```

This file contains GPS data, with a date, a timestamp, and longitude/latitude 
coordinates. Note that the coordinates can also be X/Y cartesian (or projected) 
coordinates (e.g. as returned by video tracking software, or if you projected 
your GPS data on a given reference grid).

The first step of the analysis process is to transform this imported data into 
a standardized trajectory data table that will be usable by all the functions in 
the `swaRm` package. 

```{r, message=FALSE, warning=FALSE, results='hide'}
library(swaRm)
traj <- makeTraj(x = dat$lon, y = dat$lat, id = "01", 
                 date = dat$date, time = dat$time, 
                 date.format = "ymd", time.format = "hms",
                 geo = TRUE)  # Set 'geo' to FALSE if working with cartesian
                              # (i.e. non geographic) coordinates
traj
```

Here `makeTraj` returns a table containing `r nrow(traj)` observations (each row
is an observation) and 4 columns: `id`, `time`, `lon` and `lat` (or `x` and `y` 
if working with projected data). `id` is a unique identifier chosen by you to 
distinguish between different trajectories when merging multiple tables together
(we will see this later in this tutorial). `time` is a standardized timestamp
constructed from the dates and times we provided the `makeTraj` function. 

Trajectory tables are derived from [`data.table`](https://cran.r-project.org/package=data.table) 
objects. As such, they retain all the properties of `data.table` objects and can 
be manipulated in the same ways `data.table` objects can be. This includes the 
possibility to use the functions from the [`dplyr`](https://cran.r-project.org/package=dplyr) 
package as we will see later on. `data.table` objects behave like regular 
`data.frame` objects, but come with additional functionalities and significant 
gains in processing speed compared to `data.frame` objects. 

[Back to top]("#")

---

# Dealing with errors and missing observations

Errors and missing observations are common problems with tracking data, for 
instance when working in areas with poor GPS satellite covering. `swaRm` 
provides a set of convenience functions to automatically detect and correct some
of the most common types of errors. Detection and correction are handled by 
separate functions to allow users to develop their own correction functions for 
instance. 

These functions are meant to assist the user during the processing of his/her 
tracking data. However, as every automated method, they are not 100% reliable 
and a manual inspection of the data is recommended to ensure that all errors 
were correctly detected and corrected appropriately. It is also recommended that
you keep the original tracking data untouched in order to facilitate the 
comparison between the data sets before and after the correction is applied. 
Note as well that the order in which you apply these different corrections will 
have an impact on the final state of your data.

## Missing observations

Missing observations are probably the most common type of errors in tracking 
data. They can have a number of origins (e.g. GPS tag losing satellite 
connection, animal moving out of the camera field of view, read/write errors, 
etc.). The `findMissing` function is here to help you identify this missing data. 
Note that this function works better with data that was collected at regular 
time intervals. It will most likely return weird results if it is not the case. 

```{r, message=FALSE, warning=FALSE}
missing <- findMissing(traj)
missing
```

`findMissing` returns a data frame with two columns. The `time` column contains
timestamps at which the function believes observations are missing. The `type`
column indicates whether the observation is truly missing (i.e. was never 
recorded) or if the timestamp of the observation was set to NA during recording
or during the importation of the data (e.g. because the date or time info were
not formatted properly). You can then decide what to do about this missing data: 
ignore it, correct it with your own algorithm, or use the automated `fixMissing` 
function provided with the `swaRm` package. 

```{r, message=FALSE, warning=FALSE}
traj01 <- fixMissing(traj) 
traj01[1:40, ]
```

Here the function added two new observations at rows 3 and 4 (indicated by the 
`MISSING` error tag) and fixed to NA timestamps at rows 26 and 36 (indicated by 
the `NA` error tag).

Note that all error correction function will add the extra `error` column to the 
trajectory table in order to indicate which observations were corrected. This 
can be useful for instance to check that the automated correction did work 
properly.

## Duplicated timestamps

Duplicated timestamps are a less common type of errors. They can be caused by 
writing errors for instance. The function `findTimeDup` is here to help you 
identify these potential errors. 

```{r, message=FALSE, warning=FALSE}
time_dup <- findTimeDup(traj01) 
time_dup
```

The function `fixTimeDup` will then attempt to automatically correct the 
duplicated timestamp. If a timestamps is missing where the duplicated timestamp 
is, the function will replace the duplicated timestamp with the missing one. 
Otherwise, the duplicated timestamp will be replaced by NA. 

```{r, message=FALSE, warning=FALSE}
traj01 <- fixTimeDup(traj01)
traj01[1:20, ]
```

Here the duplicated timestamp corresponds to an already existing observation 
(hence the `<NA>` created by the `fixTimeDup` function in the `time` column to 
replace the duplicated timestamp). We will simply remove it here using the 
`filter` function in the `dplyr` package. 

```{r, message=FALSE, warning=FALSE}
library(dplyr)
traj01 <- filter(traj01, -11)
traj01[1:20, ]
```

## Inconsistent locations



```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- fixLOCSEQ(traj01) 
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## NA locations

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- fixLOCNA(traj01) 
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

[Back to top]("#")

---

# Representing a geolocalized trajectory table using ggplot2 and ggmap

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(ggmap)

myLocation <- c(lon = mean(range(traj01$lon)), lat = mean(range(traj01$lat)))
myMap <- get_map(location = myLocation, source = "google", 
                 maptype = "satellite", zoom = 17, scale = 2)

ggmap(myMap) + 
  geom_path(data = traj01, aes(x = lon, y = lat, color = id), size = 1) +
  xlab("Longitude") + ylab("Latitude") +
  xlim(min(traj01$lon), max(traj01$lon)) + 
  ylim(min(traj01$lat), max(traj01$lat)) + 
  guides(color = FALSE)
```

[Back to top]("#")

---

# Computing the basic parameters of a trajectory

## Linear distances between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
library(dplyr) # I will use dplyr from this point foward to facilitate the 
               # manipulation of the trajectory table

traj01 <- mutate(traj01, 
                 linDist = linDist(x = lon, y = lat, geo = TRUE),
                 cumDist = cumsum(linDist))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Linear speeds between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01, 
                 linSpeed = linSpeed(x = lon, y = lat, t = time, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Linear accelerations between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01,
                 linAcc = linAcc(x = lon, y = lat, t = time, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Headings between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01,
                 heading = heading(x = lon, y = lat, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Angular speeds between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01,
                 angSpeed = angSpeed(x = lon, y = lat, t = time, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Angular accelerations between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01,
                 angAcc = angAcc(x = lon, y = lat, t = time, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

[Back to top]("#")

---

# Working with multiple trajectories

## Load multiple files in memory and compute all basic trajectory parameters

```{r, message=FALSE, warning=FALSE, results='hide'}
filePaths <- dir(system.file("extdata", package = "swaRm"), full.names = TRUE)

trajs <- lapply(filePaths, function(path) {
  dat <- read.csv(path) 
  makeTraj(x = dat$lon, y = dat$lat, date = dat$date, time = dat$time,
           id = gsub(".*/|.csv.*", "\\1", path), geo = TRUE) %>%
    fixTIMEDUP() %>% fixMISSING() %>% fixTIMESEQ() %>% 
    fixTIMENA() %>% fixLOCSEQ() %>% fixLOCNA() %>%
    mutate(linDist = linDist(lon, lat, geo = TRUE)) %>%
    mutate(cumDist = cumsum(linDist)) %>%
    mutate(linSpeed = linSpeed(lon, lat, time, geo = TRUE),
           linAcc = linAcc(lon, lat, time, geo = TRUE),
           heading = heading(lon, lat, geo = TRUE),
           angSpeed = angSpeed(lon, lat, time, geo = TRUE),
           angAcc = angAcc(lon, lat, time, geo = TRUE))
}) %>% data.table::rbindlist()

head(trajs)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(trajs))
```

## Representing the geolocalized trajectories using ggplot2 and ggmap

```{r, message=FALSE, warning=FALSE}
myLocation <- c(lon = mean(range(trajs$lon)), lat = mean(range(trajs$lat)))
myMap <- get_map(location = myLocation, source = "google", 
                 maptype = "satellite", zoom = 17, scale = 2)

ggmap(myMap) + 
  geom_path(data = trajs, aes(x = lon, y = lat, color = id), size = 0.8) +
  xlab("Longitude") + ylab("Latitude") +
  xlim(min(trajs$lon), max(trajs$lon)) + 
  ylim(min(trajs$lat), max(trajs$lat)) + 
  guides(color = FALSE)
```

## Summarizing group properties

### Calculating the centroid of the trajectories

```{r, message=FALSE, warning=FALSE}
trajSummary <- group_by(trajs, time) %>%
  do(centroid(lon, lat, geo = TRUE))

ggmap(myMap) + 
  geom_path(data = trajs, aes(x = lon, y = lat, group = id), size = 0.8, color = "white") +
  geom_path(data = trajSummary, aes(x = lon, y = lat), size = 1, color = "red") +
  xlab("Longitude") + ylab("Latitude") +
  xlim(min(trajs$lon), max(trajs$lon)) + 
  ylim(min(trajs$lat), max(trajs$lat))
```

### Calculating the distances to the centroid of the trajectories

```{r, message=FALSE, warning=FALSE}
trajs <- group_by(trajs, time) %>%
  mutate(distToCentroid = dist2centroid(lon, lat, geo = TRUE))

trajSummary <- group_by(trajs, time) %>% 
  summarize(distToCentroid = mean(distToCentroid)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = distToCentroid)) +
  geom_line() + 
  xlab("Time") + ylab("Distance to the group's centroid (m)") + 
  ylim(0, NA)
```

### Determining the identity of and distance to the nearest neighbor

```{r, message=FALSE, warning=FALSE}
trajs <- group_by(trajs, time) %>%
  mutate(nearNeighbor = nn(lon, lat, id, geo = TRUE),
         nearNeighborDist = nnd(lon, lat, geo = TRUE))

trajSummary <- group_by(trajs, time) %>% 
  summarize(nearNeighborDist = mean(nearNeighborDist)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = nearNeighborDist)) +
  geom_line() + 
  xlab("Time") + ylab("Mean distance to nearest neighbor (m)") + 
  ylim(0, NA)
```

### Determining which individuals are on the group's convex hull

```{r, message=FALSE, warning=FALSE}
trajs <- group_by(trajs, time) %>%
  mutate(isChull = isChull(lon, lat))

# Plot the convex hull for a randomly chose timestamp
randTime <- trajs$time[sample(1:nrow(trajs), 1)]
subTraj <- filter(trajs, time == randTime)
chullPol <- filter(subTraj, isChull > 0) %>%
  arrange(isChull)
  
myLocation <- c(lon = mean(range(subTraj$lon)), lat = mean(range(subTraj$lat)))
myMap <- get_map(location = myLocation, source = "google", 
                 maptype = "satellite", zoom = 19, scale = 2)

ggmap(myMap) + 
  geom_polygon(data = chullPol, aes(lon, lat), fill = "red", alpha = 0.25) +
  geom_point(data = subTraj, aes(lon, lat), size = 3, color = "white") + 
  geom_point(data = subTraj, aes(lon, lat, color = id), size = 2) + 
  xlab("Longitude") + ylab("Latitude") +
  xlim(min(subTraj$lon), max(subTraj$lon)) + 
  ylim(min(subTraj$lat), max(subTraj$lat)) + 
  guides(color = FALSE)
```

### Measuring the perimeter and surface area of the group's convex hull

```{r, message=FALSE, warning=FALSE}
trajSummary <- group_by(trajs, time) %>% 
  summarize(chullPerim = chullPerimeter(lon, lat, geo = TRUE),
            chullArea = chullArea(lon, lat, geo = TRUE)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = chullPerim)) +
  geom_line() + 
  xlab("Time") + ylab("Perimeter of the group's convex hull (m)") + 
  ylim(0, NA)

ggplot(trajSummary, aes(x = time, y = chullArea)) +
  geom_line() + 
  xlab("Time") + ylab(bquote("Surface area of the group's convex hull (" * m ^ 2 * ")")) + 
  ylim(0, NA)
```

### Estimating the group's shape

The group's general shape is estimated by fitting a confidence ellipse on either 
the cooordinates of all the group members, or only those belonging to the convex
hull of the group (we will use the first method here). 

From this ellipse, we can extract two shape parameters:

1. Sphericity: this is calculated as the ratio between the short and long axis 
of the ellipse. A ratio of 1 indicates a perfectly circular ellipse. Lower ratios
indicate that the ellipse is elongated in a particular direction. 

```{r, message=FALSE, warning=FALSE}
trajSummary <- group_by(trajs, time) %>% 
  summarize(sphericity = sphericity(lon, lat)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = sphericity)) +
  geom_line() + 
  xlab("Time") + ylab("Group's sphericity") + 
  ylim(0, 1)
```

2. Stretch direction: this is calculated as the angle (in radians) between the 
major axis of the ellipse and the x-axis. It should always be in [-$\pi/2$,$\pi/2$].

```{r, message=FALSE, warning=FALSE}
trajSummary <- group_by(trajs, time) %>% 
  summarize(stretch = stretch(lon, lat)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = stretch)) +
  geom_line() + 
  xlab("Time") + ylab("Group's sphericity") + 
  ylim(-pi / 2, pi / 2)
```
[Back to top]("#")

---

