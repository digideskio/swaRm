---
title: "`swaRm` - a package for processing collective movement data"
author: "Simon Garnier - <a href='https://twitter.com/sjmgarnier'>@sjmgarnier</a>"
date: "`r Sys.Date()`"
output:
  html_document:
    css: custom.css
    fig_caption: yes
    fig_height: 6
    fig_width: 8
    number_sections: yes
    theme: cosmo
    highlight: pygments
    toc: yes
  pdf_document:
    toc: yes
vignette: |
  %\VignetteIndexEntry{Vignette Title} 
  %\VignetteEngine{knitr::rmarkdown} 
  %\VignetteEncoding{UTF-8}
---

```{r, message=FALSE, warning=FALSE, include=FALSE}
library(DT)
options(DT.options = list(searching = FALSE, paging = FALSE))
```

---

# Introduction

The goal of this vignette is to demonstrate the functionalities of the `swaRm` 
package for processing collective movement data. 

[Back to top]("#")

---

# Installation

`swaRm` can be installed from the [SwarmLab](http://www.theswarmlab.com)'s 
[`drat` repository](https://github.com/swarm-lab/drat) by running the following
lines in your R terminal: 

```{r, eval=FALSE, message=FALSE, warning=FALSE}
install.packages("drat")  # This line is required if drat is not present 
                          # in your R installation.

drat::addRepo("swarm-lab")
install.packages("swaRm")
```

If you want to receive package updates automatically, you can add the `drat` 
repository to your R installation permanently by adding the line 
`drat::addRepo("swarm-lab")` to your `.Rprofile` file.

[Back to top]("#")

---

# Preparing a trajectory data table

The `swaRm` package ships with a number of example data files that we will use 
for demonstrating its functioning. 

First, we will load in memory the first of these example data files. 

```{r, message=FALSE, warning=FALSE, results='hide'}
filePath <- system.file("extdata/01.csv", package = "swaRm")
dat <- read.csv(filePath)
head(dat)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(dat))
```

This file contains GPS data, with a date, a timestamp, and longitude-latitude 
coordinates. Note that the coordinates can also be more classical X-Y cartesian
coordinates. 

The first step of the analysis process is to transform this imported data into 
a standard trajectory data table that will be usable by all the function in the 
`swaRm` package. 

```{r, message=FALSE, warning=FALSE, results='hide'}
library(swaRm)
traj <- makeTraj(x = dat$lon, y = dat$lat, id = "01", 
                 date = dat$date, time = dat$time, 
                 date.format = "ymd", time.format = "hms",
                 geo = TRUE)  # Set 'geo' to FALSE if working with cartesian
                              # (i.e. non geographic) coordinates

head(traj)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj))
```

[Back to top]("#")

---

# Dealing with errors and missing observations

Errors and missing observations are common problems with tracking data, for 
instance when working in areas with poor GPS satellite covering. `swaRm` 
provides a set of convenience functions to automatically detect and correct some
of the most common types of errors. These functions will add an extra "error" 
column to the trajectory table that will indicate what type of error (if any) 
was detected and corrected for each time point.

These functions are meant to assist the user during the processing of his/her 
tracking data. However, as every automated method, they are not 100% reliable 
and a manual inspection of the data is recommended to ensure that all errors 
were correctly detected and corrected appropriately. It is also recommended that
you keep the original tracking data untouched in order to facilitate the 
comparison between the data sets before and after the correction is applied. 
Note as well that the order in which you apply these different corrections will 
have an impact on the final state of your data.

## Missing observations

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- fixMISSING(traj) 
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Duplicated timestamps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- fixTIMEDUP(traj01) 
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Inconsistent timestamps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- fixTIMESEQ(traj01) 
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## NA timestamps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- fixTIMENA(traj01) 
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Inconsistent locations

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- fixLOCSEQ(traj01) 
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## NA locations

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- fixLOCNA(traj01) 
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

[Back to top]("#")

---

# Representing a geolocalized trajectory table using ggplot2 and ggmap

```{r, message=FALSE, warning=FALSE}
library(ggplot2)
library(ggmap)

myLocation <- c(lon = mean(range(traj01$lon)), lat = mean(range(traj01$lat)))
myMap <- get_map(location = myLocation, source = "google", 
                 maptype = "satellite", zoom = 17, scale = 2)

ggmap(myMap) + 
  geom_path(data = traj01, aes(x = lon, y = lat, color = id), size = 1) +
  xlab("Longitude") + ylab("Latitude") +
  xlim(min(traj01$lon), max(traj01$lon)) + 
  ylim(min(traj01$lat), max(traj01$lat)) + 
  guides(color = FALSE)
```

[Back to top]("#")

---

# Computing the basic parameters of a trajectory

## Linear distances between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
library(dplyr) # I will use dplyr from this point foward to facilitate the 
               # manipulation of the trajectory table

traj01 <- mutate(traj01, 
                 linDist = linDist(x = lon, y = lat, geo = TRUE),
                 cumDist = cumsum(linDist))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Linear speeds between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01, 
                 linSpeed = linSpeed(x = lon, y = lat, t = time, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Linear accelerations between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01,
                 linAcc = linAcc(x = lon, y = lat, t = time, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Headings between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01,
                 heading = heading(x = lon, y = lat, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Angular speeds between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01,
                 angSpeed = angSpeed(x = lon, y = lat, t = time, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

## Angular accelerations between successive steps

```{r, message=FALSE, warning=FALSE, results='hide'}
traj01 <- mutate(traj01,
                 angAcc = angAcc(x = lon, y = lat, t = time, geo = TRUE))
head(traj01)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(traj01))
```

[Back to top]("#")

---

# Working with multiple trajectories

## Load multiple files in memory and compute all basic trajectory parameters

```{r, message=FALSE, warning=FALSE, results='hide'}
filePaths <- dir(system.file("extdata", package = "swaRm"), full.names = TRUE)

trajs <- lapply(filePaths, function(path) {
  dat <- read.csv(path) 
  makeTraj(x = dat$lon, y = dat$lat, date = dat$date, time = dat$time,
           id = gsub(".*/|.csv.*", "\\1", path), geo = TRUE) %>%
    fixTIMEDUP() %>% fixMISSING() %>% fixTIMESEQ() %>% 
    fixTIMENA() %>% fixLOCSEQ() %>% fixLOCNA() %>%
    mutate(linDist = linDist(lon, lat, geo = TRUE)) %>%
    mutate(cumDist = cumsum(linDist)) %>%
    mutate(linSpeed = linSpeed(lon, lat, time, geo = TRUE),
           linAcc = linAcc(lon, lat, time, geo = TRUE),
           heading = heading(lon, lat, geo = TRUE),
           angSpeed = angSpeed(lon, lat, time, geo = TRUE),
           angAcc = angAcc(lon, lat, time, geo = TRUE))
}) %>% data.table::rbindlist()

head(trajs)
```

```{r, echo=FALSE, message=FALSE, warning=FALSE}
DT::datatable(head(trajs))
```

## Representing the geolocalized trajectories using ggplot2 and ggmap

```{r, message=FALSE, warning=FALSE}
myLocation <- c(lon = mean(range(trajs$lon)), lat = mean(range(trajs$lat)))
myMap <- get_map(location = myLocation, source = "google", 
                 maptype = "satellite", zoom = 17, scale = 2)

ggmap(myMap) + 
  geom_path(data = trajs, aes(x = lon, y = lat, color = id), size = 0.8) +
  xlab("Longitude") + ylab("Latitude") +
  xlim(min(trajs$lon), max(trajs$lon)) + 
  ylim(min(trajs$lat), max(trajs$lat)) + 
  guides(color = FALSE)
```

## Summarizing group properties

### Calculating the centroid of the trajectories

```{r, message=FALSE, warning=FALSE}
trajSummary <- group_by(trajs, time) %>%
  do(centroid(lon, lat, geo = TRUE))

ggmap(myMap) + 
  geom_path(data = trajs, aes(x = lon, y = lat, group = id), size = 0.8, color = "white") +
  geom_path(data = trajSummary, aes(x = lon, y = lat), size = 1, color = "red") +
  xlab("Longitude") + ylab("Latitude") +
  xlim(min(trajs$lon), max(trajs$lon)) + 
  ylim(min(trajs$lat), max(trajs$lat))
```

### Calculating the distances to the centroid of the trajectories

```{r, message=FALSE, warning=FALSE}
trajs <- group_by(trajs, time) %>%
  mutate(distToCentroid = dist2centroid(lon, lat, geo = TRUE))

trajSummary <- group_by(trajs, time) %>% 
  summarize(distToCentroid = mean(distToCentroid)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = distToCentroid)) +
  geom_line() + 
  xlab("Time") + ylab("Distance to the group's centroid (m)") + 
  ylim(0, NA)
```

### Determining the identity of and distance to the nearest neighbor

```{r, message=FALSE, warning=FALSE}
trajs <- group_by(trajs, time) %>%
  mutate(nearNeighbor = nn(lon, lat, id, geo = TRUE),
         nearNeighborDist = nnd(lon, lat, geo = TRUE))

trajSummary <- group_by(trajs, time) %>% 
  summarize(nearNeighborDist = mean(nearNeighborDist)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = nearNeighborDist)) +
  geom_line() + 
  xlab("Time") + ylab("Mean distance to nearest neighbor (m)") + 
  ylim(0, NA)
```

### Determining which individuals are on the group's convex hull

```{r, message=FALSE, warning=FALSE}
trajs <- group_by(trajs, time) %>%
  mutate(isChull = isChull(lon, lat))

# Plot the convex hull for a randomly chose timestamp
randTime <- trajs$time[sample(1:nrow(trajs), 1)]
subTraj <- filter(trajs, time == randTime)
chullPol <- filter(subTraj, isChull > 0) %>%
  arrange(isChull)
  
myLocation <- c(lon = mean(range(subTraj$lon)), lat = mean(range(subTraj$lat)))
myMap <- get_map(location = myLocation, source = "google", 
                 maptype = "satellite", zoom = 19, scale = 2)

ggmap(myMap) + 
  geom_polygon(data = chullPol, aes(lon, lat), fill = "red", alpha = 0.25) +
  geom_point(data = subTraj, aes(lon, lat), size = 3, color = "white") + 
  geom_point(data = subTraj, aes(lon, lat, color = id), size = 2) + 
  xlab("Longitude") + ylab("Latitude") +
  xlim(min(subTraj$lon), max(subTraj$lon)) + 
  ylim(min(subTraj$lat), max(subTraj$lat)) + 
  guides(color = FALSE)
```

### Measuring the perimeter and surface area of the group's convex hull

```{r, message=FALSE, warning=FALSE}
trajSummary <- group_by(trajs, time) %>% 
  summarize(chullPerim = chullPerimeter(lon, lat, geo = TRUE),
            chullArea = chullArea(lon, lat, geo = TRUE)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = chullPerim)) +
  geom_line() + 
  xlab("Time") + ylab("Perimeter of the group's convex hull (m)") + 
  ylim(0, NA)

ggplot(trajSummary, aes(x = time, y = chullArea)) +
  geom_line() + 
  xlab("Time") + ylab(bquote("Surface area of the group's convex hull (" * m ^ 2 * ")")) + 
  ylim(0, NA)
```

### Estimating the group's shape

The group's general shape is estimated by fitting a confidence ellipse on either 
the cooordinates of all the group members, or only those belonging to the convex
hull of the group (we will use the first method here). 

From this ellipse, we can extract two shape parameters:

1. Sphericity: this is calculated as the ratio between the short and long axis 
of the ellipse. A ratio of 1 indicates a perfectly circular ellipse. Lower ratios
indicate that the ellipse is elongated in a particular direction. 

```{r, message=FALSE, warning=FALSE}
trajSummary <- group_by(trajs, time) %>% 
  summarize(sphericity = sphericity(lon, lat)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = sphericity)) +
  geom_line() + 
  xlab("Time") + ylab("Group's sphericity") + 
  ylim(0, 1)
```

2. Stretch direction: this is calculated as the angle (in radians) between the 
major axis of the ellipse and the x-axis. It should always be in [-$\pi/2$,$\pi/2$].

```{r, message=FALSE, warning=FALSE}
trajSummary <- group_by(trajs, time) %>% 
  summarize(stretch = stretch(lon, lat)) %>%
  merge(trajSummary, by = "time")

ggplot(trajSummary, aes(x = time, y = stretch)) +
  geom_line() + 
  xlab("Time") + ylab("Group's sphericity") + 
  ylim(-pi / 2, pi / 2)
```
[Back to top]("#")

---

